"""
Red noise (Brownian noise) generation for PyFastFlow.

Provides GPU-accelerated red noise generation with 1/f² power spectrum.
Red noise has power inversely proportional to frequency squared, creating
smooth, correlated variations suitable for natural phenomena modeling.

Author: B.G.
"""

import taichi as ti
import numpy as np
from .. import pool


@ti.kernel
def red_noise_kernel(noise_field: ti.template(), amplitude: ti.f32, decay_factor: ti.f32, seed: ti.i32):
    """
    Generate red noise (1/f² spectrum) in a Taichi field.
    
    Red noise is generated by applying a recursive filter to white noise,
    creating spatially correlated values with power spectrum proportional to 1/f².
    The decay factor controls how quickly correlations decrease with distance.
    
    Args:
        noise_field: Taichi field to fill with red noise
        amplitude: Maximum amplitude of the noise output
        decay_factor: Controls correlation decay (0.0-1.0, higher = more correlation)
        seed: Random seed for reproducible results
    """
    ny, nx = noise_field.shape
    
    # First pass: generate white noise and apply horizontal correlation
    ti.loop_config(serialize=True)
    for j in range(ny):
        prev_value = 0.0
        for i in range(nx):
            # Generate white noise for this position
            # Note: Using global random state (seeded before kernel call)
            white_sample = (ti.random(ti.f32) - 0.5) * 2.0
            
            # Apply recursive filter for correlation
            filtered_value = decay_factor * prev_value + (1.0 - decay_factor) * white_sample
            noise_field[j, i] = filtered_value
            prev_value = filtered_value
    
    # Second pass: apply vertical correlation
    ti.loop_config(serialize=True)
    for i in range(nx):
        prev_value = noise_field[0, i]
        for j in range(1, ny):
            current_value = noise_field[j, i]
            filtered_value = decay_factor * prev_value + (1.0 - decay_factor) * current_value
            noise_field[j, i] = filtered_value
            prev_value = filtered_value
    
    # Normalize and scale to requested amplitude
    ti.loop_config(serialize=True)
    for j, i in noise_field:
        noise_field[j, i] *= amplitude


def red_noise(nx: int, ny: int, amplitude: float = 1.0, decay_factor: float = 0.8, 
              seed: int = 42, return_field: bool = False):
    """
    Generate red noise with 1/f² power spectrum.
    
    Creates correlated noise with power inversely proportional to frequency squared.
    Red noise exhibits long-range correlations and smooth variations, making it
    suitable for modeling natural phenomena like terrain elevation, temperature
    variations, or flow disturbances.
    
    Args:
        nx: Number of cells in x direction
        ny: Number of cells in y direction
        amplitude: Maximum amplitude of noise values (default: 1.0)
        decay_factor: Controls spatial correlation (0.0-1.0, default: 0.8)
                     Higher values create smoother, more correlated noise
                     Lower values approach white noise behavior
        seed: Random seed for reproducible results (default: 42)
        return_field: If True, return Taichi field; if False, return numpy array (default: False)
    
    Returns:
        numpy.ndarray or taichi.Field: Red noise array/field of shape (ny, nx)
        
    Example:
        # Generate smooth red noise for terrain perturbation
        terrain_noise = red_noise(256, 256, amplitude=10.0, decay_factor=0.9, seed=789)
        
        # Generate less correlated red noise
        flow_noise = red_noise(100, 100, decay_factor=0.5, return_field=True)
    """
    noise_field = pool.get_temp_field(ti.f32, (ny, nx))
    
    # Note: Taichi random state is global, seeding happens at ti.init() level
    red_noise_kernel(noise_field.field, amplitude, decay_factor, seed)
    
    if return_field:
        return noise_field.field
    else:
        result = noise_field.field.to_numpy()
        noise_field.release()
        return result